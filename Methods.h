#ifndef METHODS_H
#define METHODS_H

#include "Precise.h"

static class Methods{
private:
	//返回ln10的前1000位：
	static std::string static_ln10(){
		return "2.302585092994045684017991454684364207601101488628772976"
			"03332790096757260967735248023599720508959829834196778404228"
			"62486334095254650828067566662873690987816894829072083255546"
			"80843799894826233198528393505308965377732628846163366222287"
			"69821988674654366747440424327436515504893431493939147961940"
			"44002221051017141748003688084012647080685567743216228355220"
			"11480466371565912137345074785694768346361679210180644507064"
			"80002775026849167465505868569356734206705811364292245544057"
			"58925724208241314695689016758940256776311356919292033376587"
			"14166023010570308963457207544037084746994016826928280848118"
			"42893148485249486448719278096762712757753970276686059524967"
			"16674183485704422507197965004714951050492214776567636938662"
			"97697952211071826454973477266242570942932258279850258550978"
			"52653832076067263171643095059950878075237103331011978575473"
			"31541421808427543863591778117054309827482385045648019095610"
			"29929182431823752535770975053956518769751037497088869218020"
			"518933950723853920514463419726528728696511086257149219884998";
	}
	//牛顿法求根：
	static Precise getSqrt(Precise& x, Precise& guess, int ndigit);
	//求取ln10，1000位以内直接查表，否则用泰勒展开现算：
	static Precise getLn10(int ndigit);
	//龙贝格积分法中间函数：
	static Precise integral_short(Precise& x, int ndigit);
	//牛顿法求10次根：
	static Precise get10thRoot(Precise& x_minus_1, Precise& x0_minus_1, int ndigit);
	//牛顿法求10次根猜初值：
	static Precise guess_init(Precise& x);
public:
	//泰勒展开：
	static Precise taylor(Precise& x, int ndigit);
	//龙贝格法：
	static Precise integral(Precise& x, int ndigit);
	//开根迭代：
	static Precise rooting(Precise& x, int ndigit);
};

#endif